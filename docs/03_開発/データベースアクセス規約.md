# データベースアクセス規約

## 目次
1. [基本方針](#基本方針)
2. [SQLAlchemy使用ルール](#sqlalchemy使用ルール)
3. [モデル定義規約](#モデル定義規約)
4. [クエリ作成規約](#クエリ作成規約)
5. [トランザクション管理](#トランザクション管理)
6. [パフォーマンス最適化](#パフォーマンス最適化)
7. [セキュリティ](#セキュリティ)
8. [マイグレーション](#マイグレーション)

---

## 基本方針

### 原則
1. **ORMを使用する**: 直接SQLを書かず、SQLAlchemyのORMを使用
2. **トランザクション管理**: 明示的なトランザクション管理を行う
3. **セキュリティ優先**: SQLインジェクション対策を徹底
4. **パフォーマンス**: N+1問題を回避し、効率的なクエリを作成
5. **可読性**: わかりやすいクエリを心がける

### 禁止事項
- **生SQLの直書き禁止** - text()の使用は最小限に
- **文字列結合でのクエリ構築禁止** - SQLインジェクションリスク
- **暗黙的トランザクション禁止** - 明示的なcommit/rollback
- **select \* の使用禁止** - 必要なカラムのみ取得

---

## SQLAlchemy使用ルール

### 1. 初期化と設定

```python
# app.py
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.orm import DeclarativeBase

class Base(DeclarativeBase):
    """ベースモデルクラス"""
    pass

db = SQLAlchemy(model_class=Base)
app = Flask(__name__)

# データベース設定
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///dev.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.config['SQLALCHEMY_ECHO'] = True  # 開発環境のみ
app.config['SQLALCHEMY_ENGINE_OPTIONS'] = {
    'pool_size': 10,
    'pool_recycle': 3600,
    'pool_pre_ping': True,
}

db.init_app(app)
```

### 2. コネクションプール設定

```python
# PostgreSQL用の最適化設定
app.config['SQLALCHEMY_ENGINE_OPTIONS'] = {
    'pool_size': 10,          # コネクションプールサイズ
    'max_overflow': 20,       # 最大オーバーフロー数
    'pool_timeout': 30,       # タイムアウト秒数
    'pool_recycle': 3600,     # コネクション再利用時間
    'pool_pre_ping': True,    # 接続確認
}
```

### 3. セッション管理

```python
from contextlib import contextmanager

@contextmanager
def get_db_session():
    """データベースセッションのコンテキストマネージャー"""
    session = db.session()
    try:
        yield session
        session.commit()
    except Exception as e:
        session.rollback()
        raise
    finally:
        session.close()

# 使用例
with get_db_session() as session:
    pc = PCMaster(serial="ABC123456", pcname="20251116M")
    session.add(pc)
```

---

## モデル定義規約

### 1. 基本的なモデル定義

```python
from datetime import datetime
from sqlalchemy import Column, Integer, String, DateTime, Text
from sqlalchemy.orm import Mapped, mapped_column

class PCMaster(db.Model):
    """PC情報マスターテーブル"""

    __tablename__ = 'pc_master'

    # プライマリーキー
    id: Mapped[int] = mapped_column(Integer, primary_key=True)

    # 必須フィールド
    serial: Mapped[str] = mapped_column(
        String(50),
        unique=True,
        nullable=False,
        index=True,
        comment="PCシリアル番号"
    )
    pcname: Mapped[str] = mapped_column(
        String(20),
        nullable=False,
        comment="PC名（YYYYMMDDM形式）"
    )

    # オプショナルフィールド
    odj_path: Mapped[str] = mapped_column(
        String(255),
        nullable=True,
        comment="ODJファイルパス"
    )

    # タイムスタンプ
    created_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.now,
        nullable=False,
        comment="作成日時"
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.now,
        onupdate=datetime.now,
        nullable=False,
        comment="更新日時"
    )

    def __repr__(self):
        return f"<PCMaster(serial='{self.serial}', pcname='{self.pcname}')>"

    def to_dict(self):
        """辞書形式に変換"""
        return {
            'id': self.id,
            'serial': self.serial,
            'pcname': self.pcname,
            'odj_path': self.odj_path,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
        }
```

### 2. リレーションシップの定義

```python
from sqlalchemy import ForeignKey
from sqlalchemy.orm import relationship

class PCMaster(db.Model):
    __tablename__ = 'pc_master'

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    serial: Mapped[str] = mapped_column(String(50), unique=True, nullable=False)

    # 1対多のリレーション
    logs = relationship(
        'SetupLog',
        back_populates='pc',
        cascade='all, delete-orphan',
        lazy='dynamic'  # 遅延読み込み
    )

class SetupLog(db.Model):
    __tablename__ = 'setup_logs'

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    pc_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey('pc_master.id', ondelete='CASCADE'),
        nullable=False
    )

    # リレーション
    pc = relationship('PCMaster', back_populates='logs')
```

### 3. インデックスの定義

```python
from sqlalchemy import Index

class PCMaster(db.Model):
    __tablename__ = 'pc_master'
    __table_args__ = (
        # 複合インデックス
        Index('idx_serial_pcname', 'serial', 'pcname'),
        # ユニーク制約
        Index('idx_unique_serial', 'serial', unique=True),
    )
```

### 4. バリデーション

```python
from sqlalchemy.orm import validates

class PCMaster(db.Model):
    # ... フィールド定義 ...

    @validates('serial')
    def validate_serial(self, key, serial):
        """シリアル番号のバリデーション"""
        if not serial or len(serial) < 8:
            raise ValueError("シリアル番号は8文字以上必要です")
        if not serial.isalnum():
            raise ValueError("シリアル番号は英数字のみ使用可能です")
        return serial.upper()  # 大文字に統一

    @validates('pcname')
    def validate_pcname(self, key, pcname):
        """PC名のバリデーション（YYYYMMDDM形式）"""
        import re
        pattern = r'^\d{8}M$'
        if not re.match(pattern, pcname):
            raise ValueError("PC名はYYYYMMDDM形式である必要があります")
        return pcname
```

---

## クエリ作成規約

### 1. 基本的な検索

```python
# Good - 明示的なフィルタ
def get_pc_by_serial(serial: str) -> PCMaster:
    """シリアル番号でPC情報を取得"""
    return db.session.query(PCMaster).filter_by(serial=serial).first()

# または
def get_pc_by_serial(serial: str) -> PCMaster:
    return PCMaster.query.filter(PCMaster.serial == serial).first()

# Bad - 全件取得してからフィルタ
def get_pc_by_serial_bad(serial: str):
    all_pcs = PCMaster.query.all()
    for pc in all_pcs:
        if pc.serial == serial:
            return pc
```

### 2. 複数条件の検索

```python
from sqlalchemy import and_, or_

def search_pcs(serial: str = None, pcname: str = None, date_from: datetime = None):
    """複数条件でPC情報を検索"""
    query = db.session.query(PCMaster)

    conditions = []

    if serial:
        conditions.append(PCMaster.serial.like(f"%{serial}%"))

    if pcname:
        conditions.append(PCMaster.pcname == pcname)

    if date_from:
        conditions.append(PCMaster.created_at >= date_from)

    if conditions:
        query = query.filter(and_(*conditions))

    return query.all()
```

### 3. 集計クエリ

```python
from sqlalchemy import func

def get_pc_statistics():
    """PC統計情報を取得"""
    total_pcs = db.session.query(func.count(PCMaster.id)).scalar()

    # グループ化集計
    stats_by_date = (
        db.session.query(
            func.date(PCMaster.created_at).label('date'),
            func.count(PCMaster.id).label('count')
        )
        .group_by(func.date(PCMaster.created_at))
        .order_by(func.date(PCMaster.created_at).desc())
        .all()
    )

    return {
        'total': total_pcs,
        'by_date': [
            {'date': str(row.date), 'count': row.count}
            for row in stats_by_date
        ]
    }
```

### 4. ページネーション

```python
def get_pcs_paginated(page: int = 1, per_page: int = 20):
    """ページネーション付きでPC情報を取得"""
    pagination = (
        db.session.query(PCMaster)
        .order_by(PCMaster.created_at.desc())
        .paginate(page=page, per_page=per_page, error_out=False)
    )

    return {
        'items': [pc.to_dict() for pc in pagination.items],
        'total': pagination.total,
        'pages': pagination.pages,
        'current_page': page,
        'has_next': pagination.has_next,
        'has_prev': pagination.has_prev,
    }
```

### 5. JOIN操作

```python
def get_pcs_with_logs():
    """PC情報とログを結合して取得"""
    results = (
        db.session.query(PCMaster, SetupLog)
        .join(SetupLog, PCMaster.id == SetupLog.pc_id)
        .filter(SetupLog.status == 'completed')
        .all()
    )

    return [
        {
            'pc': pc.to_dict(),
            'log': {
                'status': log.status,
                'timestamp': log.timestamp.isoformat()
            }
        }
        for pc, log in results
    ]
```

### 6. サブクエリ

```python
from sqlalchemy import select

def get_pcs_with_latest_log():
    """各PCの最新ログと共に取得"""
    # サブクエリで各PCの最新ログIDを取得
    subq = (
        select(
            SetupLog.pc_id,
            func.max(SetupLog.id).label('latest_log_id')
        )
        .group_by(SetupLog.pc_id)
        .subquery()
    )

    # メインクエリ
    results = (
        db.session.query(PCMaster, SetupLog)
        .join(subq, PCMaster.id == subq.c.pc_id)
        .join(SetupLog, SetupLog.id == subq.c.latest_log_id)
        .all()
    )

    return results
```

---

## トランザクション管理

### 1. 基本的なトランザクション

```python
def create_pc(serial: str, pcname: str, odj_path: str):
    """PC情報を登録（トランザクション管理）"""
    try:
        pc = PCMaster(
            serial=serial,
            pcname=pcname,
            odj_path=odj_path
        )
        db.session.add(pc)
        db.session.commit()
        return pc

    except Exception as e:
        db.session.rollback()
        raise DatabaseError(f"PC登録エラー: {e}") from e
```

### 2. 複数操作のトランザクション

```python
def setup_pc_and_log(serial: str, pcname: str, odj_path: str):
    """PC登録とログ記録を1トランザクションで実行"""
    try:
        # PC情報登録
        pc = PCMaster(serial=serial, pcname=pcname, odj_path=odj_path)
        db.session.add(pc)
        db.session.flush()  # IDを取得するため

        # ログ記録
        log = SetupLog(
            pc_id=pc.id,
            status='started',
            timestamp=datetime.now()
        )
        db.session.add(log)

        # 一括コミット
        db.session.commit()

        return pc, log

    except Exception as e:
        db.session.rollback()
        raise DatabaseError(f"セットアップエラー: {e}") from e
```

### 3. ネストしたトランザクション（セーブポイント）

```python
from sqlalchemy.orm import Session

def complex_operation():
    """ネストしたトランザクション"""
    try:
        # メイントランザクション開始
        pc = PCMaster(serial="ABC123456", pcname="20251116M")
        db.session.add(pc)

        # セーブポイント作成
        savepoint = db.session.begin_nested()

        try:
            # 追加操作
            log = SetupLog(pc_id=pc.id, status='started')
            db.session.add(log)
            savepoint.commit()

        except Exception:
            # セーブポイントまでロールバック
            savepoint.rollback()
            raise

        # メインコミット
        db.session.commit()

    except Exception as e:
        db.session.rollback()
        raise
```

### 4. デコレーターによるトランザクション管理

```python
from functools import wraps

def transactional(func):
    """トランザクション管理デコレーター"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            result = func(*args, **kwargs)
            db.session.commit()
            return result
        except Exception as e:
            db.session.rollback()
            raise
    return wrapper

@transactional
def create_multiple_pcs(pc_list):
    """複数PC一括登録"""
    for pc_data in pc_list:
        pc = PCMaster(**pc_data)
        db.session.add(pc)
    return len(pc_list)
```

---

## パフォーマンス最適化

### 1. N+1問題の回避

```python
from sqlalchemy.orm import joinedload

# Bad - N+1問題発生
def get_pcs_with_logs_bad():
    pcs = PCMaster.query.all()
    for pc in pcs:
        # 各PCごとにクエリが発行される（N+1問題）
        logs = pc.logs.all()

# Good - Eager Loading
def get_pcs_with_logs_good():
    pcs = (
        PCMaster.query
        .options(joinedload(PCMaster.logs))
        .all()
    )
    # 1回のクエリで全てのログも取得
    return pcs
```

### 2. 選択的なカラム取得

```python
# Bad - 全カラム取得
def get_pc_names_bad():
    pcs = PCMaster.query.all()
    return [pc.pcname for pc in pcs]

# Good - 必要なカラムのみ取得
def get_pc_names_good():
    return [
        pcname for (pcname,) in
        db.session.query(PCMaster.pcname).all()
    ]
```

### 3. バルクインサート

```python
# Bad - 1件ずつINSERT
def insert_pcs_bad(pc_list):
    for pc_data in pc_list:
        pc = PCMaster(**pc_data)
        db.session.add(pc)
        db.session.commit()  # 毎回コミット（遅い）

# Good - バルクインサート
def insert_pcs_good(pc_list):
    pcs = [PCMaster(**pc_data) for pc_data in pc_list]
    db.session.bulk_save_objects(pcs)
    db.session.commit()  # 1回だけコミット
```

### 4. バルクアップデート

```python
# Good - バルクアップデート
def update_pc_status_bulk(serial_list, new_status):
    """複数PCのステータスを一括更新"""
    db.session.query(PCMaster).filter(
        PCMaster.serial.in_(serial_list)
    ).update(
        {PCMaster.status: new_status},
        synchronize_session='fetch'
    )
    db.session.commit()
```

### 5. インデックスの活用

```python
# インデックスが使われるクエリ
def search_by_indexed_field(serial):
    # serialにインデックスがある場合、高速
    return PCMaster.query.filter_by(serial=serial).first()

# インデックスが使われないクエリ（避ける）
def search_by_like_prefix(serial_prefix):
    # LIKE '%ABC%' はインデックスが使われない
    return PCMaster.query.filter(
        PCMaster.serial.like(f'%{serial_prefix}%')
    ).all()

# 前方一致ならインデックスが使われる
def search_by_like_prefix_good(serial_prefix):
    return PCMaster.query.filter(
        PCMaster.serial.like(f'{serial_prefix}%')
    ).all()
```

---

## セキュリティ

### 1. SQLインジェクション対策

```python
# Bad - SQLインジェクションリスク
def search_pc_unsafe(serial):
    sql = f"SELECT * FROM pc_master WHERE serial = '{serial}'"
    result = db.session.execute(sql)

# Good - パラメータバインディング
def search_pc_safe(serial):
    return PCMaster.query.filter_by(serial=serial).first()

# text()を使う場合もバインド変数を使用
from sqlalchemy import text

def search_pc_with_text(serial):
    sql = text("SELECT * FROM pc_master WHERE serial = :serial")
    result = db.session.execute(sql, {"serial": serial})
    return result.fetchall()
```

### 2. 入力検証

```python
def create_pc_with_validation(serial: str, pcname: str):
    """入力検証付きでPC作成"""
    # シリアル番号検証
    if not serial or not serial.isalnum():
        raise ValueError("シリアル番号は英数字のみ使用可能です")

    # PC名検証（YYYYMMDDM形式）
    import re
    if not re.match(r'^\d{8}M$', pcname):
        raise ValueError("PC名はYYYYMMDDM形式である必要があります")

    # 既存チェック
    existing = PCMaster.query.filter_by(serial=serial).first()
    if existing:
        raise ValueError(f"シリアル番号 {serial} は既に登録されています")

    pc = PCMaster(serial=serial, pcname=pcname)
    db.session.add(pc)
    db.session.commit()
    return pc
```

### 3. 権限チェック

```python
from flask_login import current_user

def delete_pc(pc_id: int):
    """PC削除（管理者のみ）"""
    if not current_user.is_admin:
        raise PermissionError("管理者権限が必要です")

    pc = PCMaster.query.get_or_404(pc_id)
    db.session.delete(pc)
    db.session.commit()
```

---

## マイグレーション

### 1. Flask-Migrate初期化

```bash
# マイグレーション初期化
flask db init

# マイグレーションファイル作成
flask db migrate -m "Initial migration"

# マイグレーション適用
flask db upgrade

# ロールバック
flask db downgrade
```

### 2. マイグレーションファイルの例

```python
# migrations/versions/xxx_add_status_column.py

from alembic import op
import sqlalchemy as sa

# Revision ID
revision = 'abc123'
down_revision = 'def456'
branch_labels = None
depends_on = None

def upgrade():
    """アップグレード処理"""
    op.add_column(
        'pc_master',
        sa.Column('status', sa.String(20), nullable=True)
    )

    # デフォルト値設定
    op.execute("UPDATE pc_master SET status = 'active'")

    # NOT NULL制約追加
    op.alter_column('pc_master', 'status', nullable=False)

def downgrade():
    """ダウングレード処理"""
    op.drop_column('pc_master', 'status')
```

### 3. データマイグレーション

```python
def upgrade():
    """既存データの更新を含むマイグレーション"""
    # テーブル構造変更
    op.add_column('pc_master', sa.Column('new_field', sa.String(50)))

    # データマイグレーション
    connection = op.get_bind()
    connection.execute(
        sa.text("""
            UPDATE pc_master
            SET new_field = CONCAT('prefix_', old_field)
            WHERE old_field IS NOT NULL
        """)
    )
```

---

## エラーハンドリング

```python
from sqlalchemy.exc import (
    IntegrityError,
    SQLAlchemyError,
    DatabaseError
)

def safe_create_pc(serial: str, pcname: str):
    """エラーハンドリング付きPC作成"""
    try:
        pc = PCMaster(serial=serial, pcname=pcname)
        db.session.add(pc)
        db.session.commit()
        return pc

    except IntegrityError as e:
        db.session.rollback()
        if 'UNIQUE constraint' in str(e):
            raise ValueError(f"シリアル番号 {serial} は既に存在します") from e
        raise

    except DatabaseError as e:
        db.session.rollback()
        raise RuntimeError("データベースエラーが発生しました") from e

    except SQLAlchemyError as e:
        db.session.rollback()
        raise RuntimeError(f"予期しないエラー: {e}") from e
```

---

## ベストプラクティスまとめ

### DO（推奨）
- ORMを使用する
- 明示的なトランザクション管理
- パラメータバインディングを使用
- 必要なカラムのみ取得
- インデックスを活用
- Eager Loadingで N+1 問題を回避
- バリデーションを実装
- エラーハンドリングを適切に行う

### DON'T（非推奨）
- 生SQLの直書き
- 文字列結合でクエリ構築
- SELECT * の使用
- 暗黙的トランザクション
- N+1 問題の放置
- インデックスなしの大量データ検索
- バリデーションなしの登録

---

## 参考資料

- [SQLAlchemy公式ドキュメント](https://docs.sqlalchemy.org/)
- [Flask-SQLAlchemy公式ドキュメント](https://flask-sqlalchemy.palletsprojects.com/)
- [Flask-Migrate公式ドキュメント](https://flask-migrate.readthedocs.io/)
